name: Build and push changed services

on:
  push:
    branches: [main, dev, ci-cd-test]
  pull_request:
    branches: [main, dev, ci-cd-test]

permissions:
  contents: read
  packages: write
  id-token: write

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Set up JDK 17 and 21
        uses: actions/setup-java@v4
        with:
          java-version: |
            17
            21
          distribution: "temurin"
          cache: "maven"

      - name: Determine changed top-level dirs
        id: changes
        run: |
          set -euo pipefail
          # Determine base ref: prefer pull_request base, otherwise previous commit
          if [ -n "${{ github.event.pull_request.head.sha || '' }}" ]; then
            BASE_REF="${{ github.event.pull_request.base.sha }}"
          else
            BASE_REF="${{ github.sha }}~1"
          fi
          echo "BASE_REF=$BASE_REF"
          git fetch --no-tags --prune --depth=50 origin

          # Check if this is the first commit or base ref doesn't exist
          if ! git rev-parse --verify "$BASE_REF" >/dev/null 2>&1; then
            echo "First commit detected - building all services"
            SERVICES=$(find . -maxdepth 1 -type d ! -name '.' ! -name '..' ! -name '.git' ! -name '.github' ! -name 'infra' ! -name 'docs' ! -name 'contracts' ! -name 'http' ! -name 'scripts' ! -name 'target' -exec basename {} \; | tr '\n' ' ')
          else
            CHANGED_FILES=$(git diff --name-only "$BASE_REF" "${{ github.sha }}" || true)
            echo "Changed files:"
            echo "$CHANGED_FILES"
            # extract top-level directory names
            SERVICES=$(echo "$CHANGED_FILES" | awk -F/ '{print $1}' | sort -u | tr '\n' ' ')
            
            # Check if only .github or non-service directories changed
            # In that case, build all services (likely first workflow run)
            FILTERED_SERVICES=""
            for svc in $SERVICES; do
              case "$svc" in
                .github|infra|docs|contracts|http|scripts|target|README.md|pom.xml)
                  ;;
                *)
                  FILTERED_SERVICES="$FILTERED_SERVICES $svc"
                  ;;
              esac
            done
            
            if [ -z "$FILTERED_SERVICES" ] && [ -n "$SERVICES" ]; then
              echo "Only non-service directories changed (likely adding CI/CD) - building all services"
              SERVICES=$(find . -maxdepth 1 -type d ! -name '.' ! -name '..' ! -name '.git' ! -name '.github' ! -name 'infra' ! -name 'docs' ! -name 'contracts' ! -name 'http' ! -name 'scripts' ! -name 'target' -exec basename {} \; | tr '\n' ' ')
            fi
          fi

          echo "Services to process: $SERVICES"
          echo "services=$SERVICES" >> $GITHUB_OUTPUT

      - name: Build & push images for changed services
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          SHORT_SHA: ${{ github.sha }}
        run: |
          set -eu
          services_str="${{ steps.changes.outputs.services }}"
          echo "Services detected: $services_str"
          read -r -a services <<< "$services_str"
          if [ ${#services[@]} -eq 0 ]; then
            echo "No top-level changes detected; nothing to build"
            exit 0
          fi
          for svc in "${services[@]}"; do
            # skip common top-level directories that are not services
            case "$svc" in
              .github|infra|docs|contracts|http|scripts|target|README.md|pom.xml)
                echo "Skipping $svc (not a service)"
                continue
                ;;
            esac
            if [ ! -d "$svc" ]; then
              echo "Skipping $svc: not a directory"
              continue
            fi
            if [ ! -f "$svc/Dockerfile" ] && [ ! -f "$svc/Dockerfile.prebuilt" ] && [ ! -f "$svc/docker/Dockerfile" ]; then
              echo "Skipping $svc: no Dockerfile found"
              continue
            fi

            # Build Maven projects before Docker build (only for Dockerfile.prebuilt)
            # Multi-stage Dockerfiles build inside Docker, so skip pre-building
            if [ -f "$svc/pom.xml" ] && [ -f "$svc/Dockerfile.prebuilt" ]; then
              echo "Building Maven project for $svc (Dockerfile.prebuilt detected)"
              
              # Detect Java version from pom.xml
              JAVA_VERSION=$(grep -oP '<java\.version>\K[0-9]+' "$svc/pom.xml" | head -1 || echo "17")
              echo "Detected Java version: $JAVA_VERSION"
              
              cd "$svc"
              if [ -f "./mvnw" ]; then
                chmod +x ./mvnw
                JAVA_HOME=$(echo $JAVA_HOME_${JAVA_VERSION}_X64) ./mvnw clean package -DskipTests
              else
                JAVA_HOME=$(echo $JAVA_HOME_${JAVA_VERSION}_X64) mvn clean package -DskipTests
              fi
              cd ..
            elif [ -f "$svc/pom.xml" ] && [ -f "$svc/Dockerfile" ]; then
              echo "Skipping Maven pre-build for $svc (multi-stage Dockerfile will build inside Docker)"
            fi

            IMAGE_SHA=${DOCKERHUB_USERNAME}/${svc}:${SHORT_SHA::8}
            
            # Determine additional tags based on branch
            ADDITIONAL_TAGS=""
            if [ "${{ github.ref }}" == "refs/heads/main" ]; then
              ADDITIONAL_TAGS="--tag ${DOCKERHUB_USERNAME}/${svc}:latest"
              echo "Building and pushing $IMAGE_SHA and ${DOCKERHUB_USERNAME}/${svc}:latest from $svc"
            elif [ "${{ github.ref }}" == "refs/heads/dev" ]; then
              ADDITIONAL_TAGS="--tag ${DOCKERHUB_USERNAME}/${svc}:dev-latest"
              echo "Building and pushing $IMAGE_SHA and ${DOCKERHUB_USERNAME}/${svc}:dev-latest from $svc"
            else
              echo "Building and pushing $IMAGE_SHA from $svc"
            fi

            # Choose Dockerfile and determine build context
            DOCKERFILE=""
            BUILD_CONTEXT="."
            
            if [ -f "$svc/Dockerfile" ]; then
              DOCKERFILE="$svc/Dockerfile"
              # Check if Dockerfile uses service-prefixed paths (e.g., "COPY discovery-service/src")
              # or simple paths (e.g., "COPY src")
              if grep -q "COPY $svc/" "$DOCKERFILE"; then
                # Uses service-prefixed paths -> build from repo root
                BUILD_CONTEXT="."
                echo "Using repo root as build context (service-prefixed paths detected)"
              else
                # Uses simple relative paths -> build from service directory
                BUILD_CONTEXT="$svc"
                echo "Using service directory as build context (relative paths detected)"
              fi
            elif [ -f "$svc/Dockerfile.prebuilt" ]; then
              DOCKERFILE="$svc/Dockerfile.prebuilt"
              # Dockerfile.prebuilt expects build context to be the service directory
              BUILD_CONTEXT="$svc"
            elif [ -f "$svc/docker/Dockerfile" ]; then
              DOCKERFILE="$svc/docker/Dockerfile"
              BUILD_CONTEXT="$svc"
            fi

            # shellcheck disable=SC2086
            docker buildx build --platform linux/amd64 --push \
              --tag "$IMAGE_SHA" \
              ${ADDITIONAL_TAGS} \
              --file "$DOCKERFILE" \
              "$BUILD_CONTEXT"

            echo "Pushed images for $svc"

          done
